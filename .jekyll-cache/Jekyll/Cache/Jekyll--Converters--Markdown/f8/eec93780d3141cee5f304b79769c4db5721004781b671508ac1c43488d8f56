I"=$<p>Apart from some of the smaller improvements like CPython optimizations, deprecations
and resolution to porting issues, following are some of the major enhancements that
directly or indirectly affects the Python developer community,</p>

<h3 id="async-and-await">async and await</h3>

<p>Now we have the ability to use <code class="highlighter-rouge">async for</code> and <code class="highlighter-rouge">async with</code> inside a co-routine
function declared with <code class="highlighter-rouge">async def</code>. Inside a coroutine function, the new await expression
can be used to suspend coroutine execution until the result is available. Any object
can be awaited, as long as it implements the <code class="highlighter-rouge">__await__()</code> method.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">async</span> <span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">db</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="s">'SELECT ...'</span><span class="p">)</span></code></pre></figure>

<p><code class="highlighter-rouge">await</code> suspends the execution of <code class="highlighter-rouge">read_data</code> coroutine until <code class="highlighter-rouge">db.fetch</code> completes
and returns the result data.</p>

<h3 id="-operator">@-operator</h3>

<p>Python 3.5 provides a new infix operator <code class="highlighter-rouge">@</code> for matrix multiplication. Matrix
multiplication is a notably common operation in many fields of mathematics,
science, engineering, and the addition of <code class="highlighter-rouge">@</code> allows writing cleaner code.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">m</span>
<span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
       <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">@</span> <span class="n">m</span>
<span class="n">array</span><span class="p">([</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span></code></pre></figure>

<h3 id="unpacking">Unpacking</h3>

<p><a href="https://www.python.org/dev/peps/pep-0448">PEP 448</a> extends the allowed uses of
the <code class="highlighter-rouge">*</code> iterable unpacking operator and <code class="highlighter-rouge">**</code> dictionary unpacking operator. It
is now possible to use an arbitrary number of unpackings designed to work in the
following way,</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fn</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="s">'a'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'c'</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="o">**</span><span class="p">{</span><span class="s">'b'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'d'</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="s">'x'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s">'y'</span><span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
<span class="p">{</span><span class="s">'x'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'y'</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span></code></pre></figure>

<h3 id="type-hints">Type hints</h3>

<p>Type hints was perhaps the most talked topic in this year’s <a href="https://www.youtube.com/watch?v=2wDvzy6Hgxg">PyCon ‘15</a>,
after Guide introduced it to the world. And predictably, it increased the anticipation
amongst the developer community for all the right reasons.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">greeting</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">'Hello '</span> <span class="o">+</span> <span class="n">name</span></code></pre></figure>

<h3 id="osscandir">os.scandir()</h3>

<p>In the latest release, there is a new addition to the directory iteration function,
<code class="highlighter-rouge">os.scandir()</code>, in the standard library. Additionally, <code class="highlighter-rouge">os.walk()</code> is now implemented
using <strong>scandir</strong>, which makes it 3 to 5 times faster on POSIX systems and 7 to 20
times faster on Windows systems. This is largely achieved by greatly reducing the
number of calls to <code class="highlighter-rouge">os.stat()</code> required to walk a directory tree.</p>

<p>Additionally, <strong>scandir</strong> returns an iterator, as opposed to returning a list of
file names, which improves memory efficiency when iterating over very large directories.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">scandir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'.'</span><span class="p">)</span> <span class="ow">and</span> <span class="n">entry</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></code></pre></figure>

<p>Ofcourse, the entire list of ehancements and improvements is pretty long. Refer
the official <a href="https://docs.python.org/3.5/whatsnew/changelog.html">changelog</a>
for the complete list.</p>
:ET